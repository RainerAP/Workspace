##[[
primtypes.number = primtypes.float32
primtypes.integer = primtypes.int32
primtypes.uinteger = primtypes.uint32

if ccinfo.is_wasm and config.release then
  -- Optimization for the making the application small as possible.
  cflags "-Oz -g0 -flto"
  if ccinfo.is_wasm then
    ldflags "-Wl,--strip-all,--gc-sections,--lto-O3"
  end
end
]]

global int = @integer
global float = @number

require 'sdl2'
require 'math'
require 'memory'

##[==[
local neco_gfxdata, neco_mapdata, neco_font
local neco_default_font = {
  glyph_xadvance=8,
  glyph_yadvance=6,
  glyph_xspacing=1,
  glyph_yspacing=1,
  glyph_width=3,
  data=[[
00000000070000007070000070700000777000007070000077000000070000000700000007000000707000000000000000000000000000000000000000700000
00000000070000007070000077700000770000000070000077000000700000007000000000700000070000000700000000000000000000000000000007000000
00000000070000000000000070700000077000000700000077000000000000007000000000700000777000007770000000000000777000000000000007000000
00000000000000000000000077700000777000007000000070700000000000007000000000700000070000000700000007000000000000000000000007000000
00000000070000000000000070700000070000007070000077700000000000000700000007000000707000000000000070000000000000000700000070000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
77700000770000007770000077700000707000007770000070000000777000007770000077700000000000000000000000700000000000007000000077700000
70700000070000000070000000700000707000007000000070000000007000007070000070700000070000000700000007000000777000000700000000700000
70700000070000007770000007700000777000007770000077700000007000007770000077700000000000000000000070000000000000000070000007700000
70700000070000007000000000700000007000000070000070700000007000007070000000700000070000000700000007000000777000000700000000000000
77700000777000007770000077700000007000007770000077700000007000007770000000700000000000007000000000700000000000007000000007000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
07000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
70700000777000007700000077700000770000007770000077700000777000007070000077700000777000007070000070000000777000007700000007700000
70700000707000007700000070000000707000007700000077000000700000007070000007000000070000007700000070000000777000007070000070700000
70000000777000007070000070000000707000007000000070000000707000007770000007000000070000007070000070000000707000007070000070700000
07700000707000007770000077700000770000007770000070000000777000007070000077700000770000007070000077700000707000007070000077000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000007700000070000000077000000700000000000000
77700000070000007770000007700000777000007070000070700000707000007070000070700000777000007000000007000000007000007070000000000000
70700000707000007070000070000000070000007070000070700000707000000700000077700000007000007000000007000000007000000000000000000000
77700000770000007700000000700000070000007070000077700000777000007070000000700000700000007000000007000000007000000000000000000000
70000000077000007070000077000000070000000770000007000000777000007070000077700000777000007700000000700000077000000000000077700000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
07000000777000007770000007700000770000007770000077700000077000007070000077700000777000007070000070000000777000007700000007700000
00700000707000007070000070000000707000007000000070000000700000007070000007000000070000007070000070000000777000007070000070700000
00000000777000007700000070000000707000007700000077000000700000007770000007000000070000007700000070000000707000007070000070700000
00000000707000007070000070000000707000007000000070000000707000007070000007000000070000007070000070000000707000007070000070700000
00000000707000007770000007700000777000007770000070000000777000007070000077700000770000007070000077700000707000007070000077000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
77700000070000007770000007700000777000007070000070700000707000007070000070700000777000000770000007000000770000000000000000000000
70700000707000007070000070000000070000007070000070700000707000007070000070700000007000000700000007000000070000000070000007000000
77700000707000007700000077700000070000007070000070700000707000000700000077700000070000007700000007000000077000007770000070700000
70000000770000007070000000700000070000007070000077700000777000007070000000700000700000000700000007000000070000007000000070700000
70000000077000007070000077000000070000000770000007000000777000007070000077700000777000000770000007000000770000000000000077700000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
77777770707070707000007007777700700070000070000000777000077077000077700000777000007770000777770077777770000777000777770000070000
77777770070707007777777077000770007000700077770007770700077777000770770000777000077777007770077070777070000700007700077000777000
77777770707070707077707077000770700070000077700007777700077777007770777007777700777777707700077077777770000700007707077007777700
77777770070707007077707077707770007000700777700007777700007770000770770000777000070707007770077070000070077700007700077000777000
77777770707070700777770007777700700070000000700000777000000700000077700000707000070777000777770077777770077700000777770000070000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
00000000077777000007000007777700077777000000000000000000077777007777777070707070000000000000000000000000000000000000000000000000
00000000770077700077700000777000777077707070000070007000770707700000000070707070000000000000000000000000000000000000000000000000
70707070770007707777777000070000770007700700707007070700777077707777777070707070000000000000000000000000000000000000000000000000
00000000770077700777770000777000770007700000070000700070770707700000000070707070000000000000000000000000000000000000000000000000
00000000077777000700070007777700077777000000000000000000077777007777777070707070000000000000000000000000000000000000000000000000
00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
]]}
local neco_default_palette = {
  [0] = 0x000000,
  [1] = 0x1d2b53,
  [2] = 0x7e2553,
  [3] = 0x008751,
  [4] = 0xab5236,
  [5] = 0x5f574f,
  [6] = 0xc2c3c7,
  [7] = 0xfff1e8,
  [8] = 0xff004d,
  [9] = 0xffa300,
  [10] = 0xffec27,
  [11] = 0x00e436,
  [12] = 0x29adff,
  [13] = 0x83769c,
  [14] = 0xff77a8,
  [15] = 0xffccaa,
}
]==]

## function neco_setup(opts)
  local opt_arithmetic = #[concept(function(x) return x.type.is_niltype or x.type.is_arithmetic end)]#
  local is_arithmetic = #[concept(function(x) return x.type.is_arithmetic end)]#

  -- initialize
  ##[==[
  local function read_chars(data)
    if not data or data == '' then return '', 0, 0 end
    data = data:gsub(' +',''):gsub('\n\n+','\n')
    local width = #data:match('%w+')
    local height
    data, height = data:gsub('%s', '')
    return data, width, math.max(height,1)
  end

  local function read_u4s(data)
    if not data or data == '' then return '', 0, 0 end
    local data, width, height = read_chars(data)
    local ss = {}
    for i=0,width*height-1 do
      local x, y = i % width, i // width
      local b = tonumber(data:sub(i+1,i+1), 16)
      ss[#ss+1] = string.char(b)
    end
    return table.concat(ss), width, height
  end

  local function read_u8s(data, to_u16)
    if not data or data == '' then return '', 0, 0 end
    local data, width, height = read_chars(data)
    width = width // 2
    local ss = {}
    for i=0,width*height-1 do
      local b = tonumber(data:sub(2*i+1, 2*i+2), 16)
      ss[#ss+1] = string.char(b)
      if to_u16 then
        ss[#ss+1] = '\0'
      end
    end
    return table.concat(ss), width, height
  end

  local function build_palette_indexes(palette)
    local indexes = {}
    for i=0,#palette do
      indexes[palette[i]] = i
    end
    return indexes
  end

  local function read_indexed_ppm(filename)
    local file, open_err = io.open(filename,'rb')
    if not file then return nil, string.format('file %s: %s', filename, open_err) end
    local filedata,read_err = file:read('*a')
    file:close()
    if not filedata then return nil, read_err end
    if not filedata then return string.format('file %s: %s', filename, read_err) end
    local ppm_patt = require'nelua.thirdparty.lpegrex'.compile([[
    file <- {| 'P6' skip
               {:width: %d+ :} skip
               {:height: %d+ :} skip
               {:maxval: %d+ :} %s
               {:data: .* :} |}
    skip <- (%s / '#' (!%nl .)* %nl)+
    ]])
    local ppm = ppm_patt:match(filedata)
    if not ppm then return nil, string.format('file %s: unsupported PPM file format', filename) end
    ppm.width, ppm.height, ppm.maxval = tonumber(ppm.width), tonumber(ppm.height), tonumber(ppm.maxval)
    assert(ppm.maxval == 255)
    local pos = 1
    local data = ppm.data
    local size = ppm.height*ppm.width
    local usedcolors = {[0] = true}
    local pixels = {}
    local colors = {}
    for i=1,size do
      local color
      color, pos = string.unpack('>I3', data, pos)
      pixels[i] = color
      if not usedcolors[color] then
        colors[#colors+1] = color
        usedcolors[color] = true
      end
    end
    table.sort(colors)
    local index2color = {[0]=0}
    local color2index = {[0]=0}
    for i,color in ipairs(colors) do
      index2color[i] = color
      color2index[color] = i
    end
    local indexdata = {}
    for i=1,size do
      indexdata[i] = string.char(color2index[pixels[i]])
    end
    return table.concat(indexdata), ppm.width, ppm.height, index2color
  end

  local function read_tiled_map(filename)
    local tiledmap = dofile(opts.map)
    local tileddata = tiledmap.layers[1].data
    local mapdata = {}
    for i=1,#tileddata do
      local id = tileddata[i]
      if id ~= 0 then id = id - 1 end
      mapdata[#mapdata+1] = string.pack('I2', id)
    end
    return table.concat(mapdata), tiledmap.width, tiledmap.height
  end

  local function read_font(fontconf)
    local data, width, height
    if fontconf.image then
      fontconf.image_data, fontconf.image_width, fontconf.image_height = assert(read_indexed_ppm(fontconf.image))
    else
      fontconf.image_data, fontconf.image_width, fontconf.image_height = read_u4s(fontconf.data)
    end
    return fontconf
  end

  -- default configs
  neco_scale = opts.scale or 4
  neco_fps = opts.fps or 30
  neco_width = opts.width or 128
  neco_height = opts.height or 128
  neco_tilesize = opts.tilesize or 8
  neco_title = opts.title or 'Neco'

  -- palette
  neco_palette = opts.pal or neco_default_palette
  neco_palette_size = #neco_palette+1

  -- gfx
  if not opts.gfx then
    neco_gfxdata = string.rep('\0', neco_tilesize*neco_tilesize)
    neco_gfxwidth, neco_gfxheight = neco_tilesize, neco_tilesize
    neco_palette_size = #neco_palette+1
  elseif opts.gfx:match('%.ppm$') then
    neco_gfxdata, neco_gfxwidth, neco_gfxheight, neco_palette = assert(read_indexed_ppm(opts.gfx))
    neco_palette_size = #neco_palette+1
  else
    if neco_palette_size > 16 then
      neco_gfxdata, neco_gfxwidth, neco_gfxheight = read_u8s(opts.gfx)
    else
      neco_gfxdata, neco_gfxwidth, neco_gfxheight = read_u4s(opts.gfx)
    end
  end
  neco_numhsprites = neco_gfxwidth // neco_tilesize
  neco_numvsprites = neco_gfxheight // neco_tilesize
  neco_numsprites = neco_numhsprites*neco_numvsprites

  -- palette indexes
  neco_palette_indexes = build_palette_indexes(neco_palette)

  -- map
  if opts.map then
    if opts.map:match('%.lua') then
      neco_mapdata, neco_mapwidth, neco_mapheight = read_tiled_map(opts.map)
    else
      neco_mapdata, neco_mapwidth, neco_mapheight = read_u8s(opts.map, true)
    end
  else
    neco_mapdata, neco_mapwidth, neco_mapheight = '', 0, 0
  end

  -- gfx flags
  local empty_gff = string.rep('00', neco_numsprites)
  neco_gffdata, neco_gffwidth, neco_gffheight = read_u8s(opts.gff or empty_gff)
  if #neco_gffdata < #empty_gff then
    neco_gffdata = neco_gffdata .. empty_gff:sub(1,2*(#empty_gff-#neco_gffdata)+1)
  end

  -- font
  neco_font = read_font(opts.font or neco_default_font)

  context.rootscope.symbols.trace = symbols.print
  opts.print = opts.print or 'print'
]==]

  global Color = @record{r: byte, g: byte, b: byte, a: byte}
  global neco = @record{}
  global neco.scale <comptime> = #[neco_scale]#
  global neco.fps <comptime> = #[neco_fps]#
  global neco.width <comptime> = #[neco_width]#
  global neco.height <comptime> = #[neco_height]#
  global neco.tilesize <comptime> = #[neco_tilesize]#
  global neco.title <comptime> = #[neco_title]#
  global neco.gfxwidth <comptime> = #[neco_gfxwidth]#
  global neco.gfxheight <comptime> = #[neco_gfxheight]#
  global neco.mapwidth <comptime> = #[neco_mapwidth]#
  global neco.mapheight <comptime> = #[neco_mapheight]#
  global neco.fontwidth <comptime> = #[neco_mapwidth]#
  global neco.fontheight <comptime> = #[neco_mapheight]#
  global neco.palette: [#[neco_palette_size]#]Color
  global neco.altpalette: [#[neco_palette_size]#]byte
  global neco.scnpalette: [#[neco_palette_size]#]byte

  global neco.frametime: number
  global neco.camera: record{x: integer, y: integer}
  global neco.keydowns: [SDL_NUM_SCANCODES]boolean
  global neco.mousedowns: uint32
  global neco.renderpixels: [(neco.height)][(neco.width)]Color
  global neco.pixels: [(neco.height)][(neco.width)]byte
  local GfxPixels = @[(neco.gfxheight)][(neco.gfxwidth)]byte
  -- TODO: remove '$' usage because it is double memory usage!
  global neco.gfxpixels: GfxPixels = $(@*GfxPixels)(#[neco_gfxdata]#.data)
  local GfxFlags = @[#[neco_numsprites]#]byte
  global neco.gfxflags: GfxFlags = $(@*GfxFlags)(#[neco_gffdata]#.data)
  local MapData = @[(neco.mapheight)][(neco.mapwidth)]uint16
  global neco.map: MapData = $(@*MapData)(#[neco_mapdata]#.data)
  local FontPixels = @[#[neco_font.image_height]#][#[neco_font.image_width]#]byte
  global neco.fontpixels: FontPixels = $(@*FontPixels)(#[neco_font.image_data]#.data)

  global C4:  float32 <comptime> = 261.63
  global Cs4: float32 <comptime> = 277.18
  global D4:  float32 <comptime> = 293.66
  global Ds4: float32 <comptime> = 311.13
  global E4:  float32 <comptime> = 329.63
  global F4:  float32 <comptime> = 349.23
  global Fs4: float32 <comptime> = 369.99
  global G4:  float32 <comptime> = 392.00
  global Gs4: float32 <comptime> = 415.30
  global A4:  float32 <comptime> = 440.00
  global As4: float32 <comptime> = 466.16
  global B4:  float32 <comptime> = 493.88
  global C5:  float32 <comptime> = C4*2
  global Cs5: float32 <comptime> = Cs4*2
  global D5:  float32 <comptime> = D4*2
  global Ds5: float32 <comptime> = Ds4*2
  global E5:  float32 <comptime> = E4*2
  global F5:  float32 <comptime> = F4*2
  global Fs5: float32 <comptime> = Fs4*2
  global G5:  float32 <comptime> = G4*2
  global Gs5: float32 <comptime> = Gs4*2
  global A5:  float32 <comptime> = A4*2
  global As5: float32 <comptime> = As4*2
  global B5:  float32 <comptime> = B4*2

  ## for i=0,#neco_palette do
    ## local r, g, b = (neco_palette[i] >> 16) & 0xff, (neco_palette[i] >> 8) & 0xff, neco_palette[i] & 0xff
    neco.palette[#[i]#] = Color{r=#[r]#, g=#[g]#, b=#[b]#, a=0xff}
    neco.altpalette[#[i]#] = #[i]#
    neco.scnpalette[#[i]#] = #[i]#
  ## end

  global BTN_LEFT: integer <comptime> = 0
  global BTN_RIGHT: integer <comptime> = 1
  global BTN_UP: integer <comptime> = 2
  global BTN_DOWN: integer <comptime> = 3
  global BTN_O: integer <comptime> = 4
  global BTN_X: integer <comptime> = 5
  global BTN_MOUSE_LEFT: integer <comptime> = 6
  global BTN_MOUSE_RIGHT: integer <comptime> = 7
  global BTN_MOUSE_MIDDLE: integer <comptime> = 8

  global function cos(x: is_arithmetic) <inline,nosideeffect>
    return math.cos(x*(math.pi*2))
  end
  global function sin(x: is_arithmetic) <inline,nosideeffect>
    return -math.sin(x*(math.pi*2))
  end
  global function atan2(y: is_arithmetic, x: is_arithmetic) <inline,nosideeffect>
    return (math.pi+math.atan2(x, -y))/(math.pi*2)
  end
  global function rnd(x: is_arithmetic) <inline,nosideeffect>
    return math.random() * x
  end
  global function sgn(x: is_arithmetic) <inline,nosideeffect>
    local r: #[x.type]# <noinit>
    if x < 0 then r=-1 else r=1 end
    return r
  end

  global flr: auto = math.floor
  global abs: auto = math.abs
  global sqrt: auto = math.sqrt
  global iflr: auto = math.ifloor
  global max: auto = math.max
  global min: auto = math.min

  global function iclamp(x: is_arithmetic, min: integer, max: integer) <inline,nosideeffect>
    local r: integer
    if unlikely(x < min) then
      r = min
    elseif unlikely(x > max) then
      r = max
    else
      r = (@integer)(x)
    end
    return r
  end

  global function clamp(x: is_arithmetic, min: is_arithmetic, max: is_arithmetic)
    local r: #[x.type]# <noinit>
    if unlikely(x < min) then
      r = min
    elseif unlikely(x > max) then
      r = max
    else
      r = x
    end
    return r
  end

  -- Returns the number of seconds elapsed since the cartridge was run.
  -- This is not the real-world time, but is calculated by counting the number of times
  -- _update or _update60 is called. Multiple calls of time() from the same frame return
  -- the same result.
  global function time()
    return neco.frametime
  end
  global t: auto = time

  -- Clear the screen and reset the clipping rectangle.
  -- col defaults to 0 (black).
  global function cls(col: opt_arithmetic)
    ## if col.type.is_niltype then
      memory.zero(&neco.pixels, neco.width * neco.height)
    ## else
      local col: byte = iflr(col) % #neco.altpalette
      memory.set(&neco.pixels, col, neco.width * neco.height)
    ## end
  end

  global function pal(col: opt_arithmetic, newcol: opt_arithmetic, is_screen: opt_arithmetic)
    ## if not col.type.is_niltype then
    local col: byte = iflr(col) % #neco.altpalette
    ## end
    ## if not newcol.type.is_niltype then
    local newcol: byte = iflr(newcol) % #neco.altpalette
    ## end
    ## if not is_screen.type.is_niltype then
    if is_screen == 1 then
      ## if col.type.is_niltype then
        for i=0,<#neco.scnpalette do
          neco.scnpalette[i] = i
        end
      ## else
        neco.scnpalette[col] = newcol
      ## end
      return
    end
    ## end
    ## if col.type.is_niltype then
      for i=0,<#neco.altpalette do
        neco.altpalette[i] = i
      end
    ## else
      neco.altpalette[col] = newcol
    ## end
  end

  -- Draw sprite n (0..255) at position x, y.
  -- Width and height are 1,1 by default and specify how many sprites wide to blit.
  -- Color 0 drawn as transparent by default (see palt())
  -- flip_x=true to flip horizontally
  -- flip_y=true to flip vertically
  global function spr(n: integer,
                      x: is_arithmetic, y: is_arithmetic,
                      w: opt_arithmetic, h: opt_arithmetic,
                      flip_x: facultative(boolean),
                      flip_y: facultative(boolean))
    if unlikely(n < 0 or n >= neco.gfxwidth*neco.gfxheight) then return end
    local x, y = (@integer)(x), (@integer)(y)
    ## if w.type.is_arithmetic then
    local w = (@integer)(w)*neco.tilesize
    ## else
    local w = neco.tilesize
    ## end
    ## if h.type.is_arithmetic then
    local h = (@integer)(h)*neco.tilesize
    ## else
    local h = neco.tilesize
    ## end
    local hcount: uinteger <comptime> = (neco.gfxwidth // neco.tilesize)
    local isx = ((@uinteger)(n) % hcount) * neco.tilesize
    local isy = ((@uinteger)(n) // hcount) * neco.tilesize
    local idx = x + neco.camera.x
    local idy = y + neco.camera.y
    -- horizontal flip
    local sxf = 1
    ## if flip_x.type.is_boolean then
      if flip_x then
        sxf = -1
        isx = isx + w - 1
      end
    ## end
    -- vertical flip
    local syf = 1
    ## if flip_y.type.is_boolean then
      if flip_y then
        syf = -1
        isy = isy + h - 1
      end
    ## end
    -- clip out of bounds width
    if idx < 0 then w = w+idx; isx = isx-idx*sxf; idx = 0 end
    local idxa = idx+w - neco.width
    if idxa > 0 then w = w - idxa end
    -- clip out of bounds height
    if idy < 0 then h = h+idy; isy = isy-idy*syf; idy = 0 end
    local idya = idy+h - neco.height
    if idya > 0 then h = h - idya end
    -- -- clipped away?
    if h < 0 or w < 0 then return end
    -- blit
    for iy=0,<h do
      local sy = isy + iy*syf
      local dy = idy + iy
      for ix=0,<w do
        local sx = isx + ix*sxf
        local dx = idx + ix
        local col = neco.gfxpixels[sy][sx]
        if col ~= 0 then
          neco.pixels[dy][dx] = neco.altpalette[col]
        end
      end
    end
  end

  global function sfx(x: integer)
    --TODO
  end

  global function music(n: integer, fade_len: auto, channel_mask: auto)
    --TODO
  end

  global function sget(x: is_arithmetic, y: is_arithmetic): byte
    local x, y = (@integer)(x), (@integer)(y)
    return neco.gfxpixels[y][x]
  end

  global function sset(x: is_arithmetic, y: is_arithmetic, col: byte)
    local x, y = (@integer)(x), (@integer)(y)
    neco.gfxpixels[y][x] = col
  end

  global function fget(n: integer, flag: facultative(byte))
    ## if flag.type.is_niltype then
      return neco.gfxflags[n]
    ## else
      return (neco.gfxflags[n] & (1 << flag)) ~= 0
    ## end
  end

  global function fset(n: integer, flag: byte)
    neco.gfxflags[n] = flag
  end

  global function pget(x: is_arithmetic, y: is_arithmetic): byte
    local x, y = neco.camera.x+(@integer)(x), neco.camera.y+(@integer)(y)
    if unlikely(x < 0 or y < 0 or x >= neco.width or y >= neco.height) then return 0 end
    return neco.pixels[y][x]
  end

  global function pset(x: is_arithmetic, y: is_arithmetic, col: byte)
    local x, y = neco.camera.x+(@integer)(x), neco.camera.y+(@integer)(y)
    if unlikely(x < 0 or y < 0 or x >= neco.width or y >= neco.height) then return end
    col = neco.altpalette[col % #neco.altpalette]
    neco.pixels[y][x] = col
  end

  global function camera(x: opt_arithmetic, y: opt_arithmetic)
    ## if x.type.is_niltype then
      neco.camera.x = 0
    ## else
      neco.camera.x = -(@integer)(x)
    ## end
    ## if y.type.is_niltype then
      neco.camera.y = 0
    ## else
      neco.camera.y = -(@integer)(y)
    ## end
  end

  global function line(x0: is_arithmetic, y0: is_arithmetic, x1: is_arithmetic, y1: is_arithmetic, col: byte)
    local x0, y0 = (@integer)(neco.camera.x+x0), (@integer)(neco.camera.x+y0)
    local x1, y1 = (@integer)(neco.camera.x+x1), (@integer)(neco.camera.x+y1)
    col = neco.altpalette[col % #neco.altpalette]

    local function line_low(x0: integer, y0: integer, x1: integer, y1: integer, col: byte)
      local dx, dy = x1-x0, y1-y0
      local yi = 1
      if dy < 0 then yi = -1 dy = -dy end
      local D = 2*dy - dx
      local y = y0
      for x=x0,x1 do
        if likely(x >= 0 and y >= 0 and x < neco.width and y < neco.height) then
          neco.pixels[y][x] = col
        end
        if D > 0 then
          y = y + yi
          D = D - 2*dx
        end
        D = D + 2*dy
      end
    end

    local function line_high(x0: integer, y0: integer, x1: integer, y1: integer, col: byte)
      local dx, dy = x1-x0, y1-y0
      local xi = 1
      if dx < 0 then xi = -1 dx = -dx end
      local D = 2*dx - dy
      local x = x0
      for y=y0,y1 do
        if likely(x >= 0 and y >= 0 and x < neco.width and y < neco.height) then
          neco.pixels[y][x] = col
        end
        if D > 0 then
          x = x + xi
          D = D - 2*dy
        end
        D = D + 2*dx
      end
    end

    if math.abs(y1 - y0) < math.abs(x1 - x0) then
      if x0 > x1 then
        x0, y0, x1, y1 = x1, y1, x0, y0
      end
      line_low(x0, y0, x1, y1, col)
    else
      if y0 > y1 then
        x0, y0, x1, y1 = x1, y1, x0, y0
      end
      line_high(x0, y0, x1, y1, col)
    end
  end

  global function rectfill(x0: is_arithmetic, y0: is_arithmetic, x1: is_arithmetic, y1: is_arithmetic, col: byte)
    local x0, y0 = iclamp(neco.camera.x+x0, 0, neco.width-1), iclamp(neco.camera.y+y0, 0, neco.height-1)
    local x1, y1 = iclamp(neco.camera.x+x1, 0, neco.width-1), iclamp(neco.camera.y+y1, 0, neco.height-1)
    col = neco.altpalette[col % #neco.altpalette]
    for y=y0,y1 do
      for x=x0,x1 do
        neco.pixels[y][x] = col
      end
    end
  end

  global function circfill(x: number, y: number, r: number, col: byte)
    if unlikely(r < 0) then return end
    if r < 1 then
      pset(x, y, col)
      return
    end
    col = neco.altpalette[col % #neco.altpalette]
    x, y = neco.camera.x+x, neco.camera.y+y
    local sy, sx = -r, -r
    local ey, ex = r, r
    if y < r then sy = -y end
    if x < r then sx = -x end
    if y+r >= neco.height then ey = neco.height - y end
    if x+r >= neco.width then ex = neco.width - x end
    sy, sx, ey, ex = sy+0.5, sx+0.5, ey-0.5, ex-0.5
    local r2 = r*r
    for iy=sy,ey do
      local iy2 = iy*iy
      for ix=sx,ex do
        local ix2 = ix*ix
        if ix2+iy2 <= r2 then
          local dx, dy = x + ix, y +iy
          neco.pixels[(@integer)(dy)][(@integer)(dx)] = col
        end
      end
    end
  end

  global function map(cell_x: opt_arithmetic, cell_y: opt_arithmetic,
                      sx: opt_arithmetic, sy: opt_arithmetic,
                      cell_w: opt_arithmetic, cell_h: opt_arithmetic,
                      layers: opt_arithmetic)
    ## if cell_x.type.is_niltype then
    local cell_x <comptime> = 0
    ## else
    local cell_x = (@integer)(cell_x)
    ## end
    ## if cell_y.type.is_niltype then
    local cell_y <comptime> = 0
    ## else
    local cell_y = (@integer)(cell_y)
    ## end
    ## if cell_w.type.is_niltype then
    local cell_w <comptime> = neco.mapwidth
    ## else
    local cell_w = (@integer)(cell_w)
    ## end
    ## if cell_h.type.is_niltype then
    local cell_h <comptime> = neco.mapheight
    ## else
    local cell_h = (@integer)(cell_h)
    ## end
    ## if sx.type.is_niltype then
    local sx <comptime> = 0
    ## else
    local sx = (@integer)(sx)
    ## end
    ## if sy.type.is_niltype then
    local sy <comptime> = 0
    ## else
    local sy = (@integer)(sy)
    ## end
    for iy=0,<cell_h do
      local cy = cell_y + iy
      if unlikely(cy < 0 or cy >= neco.mapheight) then continue end
      for ix=0,<cell_w do
        local cx = cell_x + ix
        if unlikely(cx < 0 or cx >= neco.mapwidth) then continue end
        local sid = neco.map[cy][cx]
        if unlikely(sid == 0 or sid >= #neco.gfxflags) then
          continue
        end
        ## if not layers.type.is_niltype then
          if neco.gfxflags[sid] & layers ~= layers then
            continue
          end
        ## end
        local x, y = sx+ix*neco.tilesize, sy+iy*neco.tilesize
        spr(sid, x, y)
      end
    end
  end

  global function glyph(n: byte, x: is_arithmetic, y: is_arithmetic, col: byte, size: integer)
    local x, y = (@integer)(x), (@integer)(y)
    if unlikely(n < 32 or n >= 128) then return end
    n = n - 32
    local hcount <comptime> = #[neco_font.image_width // neco_font.glyph_xadvance]#
    local isx, isy = (n % hcount) * #[neco_font.glyph_xadvance]#, (n // hcount) * #[neco_font.glyph_yadvance]#
    local idx, idy = x + neco.camera.x, y + neco.camera.y
    local w = #[neco_font.glyph_width]#
    local h = #[neco_font.glyph_yadvance]#
    local dcol = neco.altpalette[col % #neco.altpalette]
    if size == 1 then
      -- clip out of bounds width
      if idx < 0 then w, isx, idx = w+idx, isx-idx, 0 end
      local idxa = idx+w - neco.width
      if idxa > 0 then w = w - idxa end
      -- clip out of bounds height
      if idy < 0 then h, isy, idy = h+idy, isy-idy, 0 end
      local idya = idy+h - neco.height
      if idya > 0 then h = h - idya end
      -- -- clipped away?
      if h < 0 or w < 0 then return end
      -- blit
      for iy=0,<h do
        local sy = isy + iy
        local dy = idy + iy
        for ix=0,<w do
          local sx = isx + ix
          local dx = idx + ix
          if neco.fontpixels[sy][sx] ~= 0 then
            neco.pixels[dy][dx] = dcol
          end
        end
      end
    else
      for iy=0,<h do
        local sy = isy + iy
        local dy = idy + iy*size
        for ix=0,<w do
          local sx = isx + ix
          local dx = idx + ix*size
          if neco.fontpixels[sy][sx] ~= 0 then
            for py=dy,<dy+size do
              if unlikely(py < 0 or py >= neco.height) then continue end
              for px=dx,<dx+size do
                if unlikely(px < 0 or px >= neco.width) then continue end
                neco.pixels[py][px] = dcol
              end
            end
          end
        end
      end
    end
  end

  global function #|opts.print|#(msg: string, x: is_arithmetic, y: is_arithmetic, col: byte, size: opt_arithmetic)
    ## if size.type.is_niltype then
    local size <comptime> = 1
    ## end
    for i=0,<msg.size do
      local n = msg.data[i]
      glyph(n, x, y, col, size)
      x = x + #[neco_font.glyph_width + neco_font.glyph_xspacing]#*size
    end
  end

  global function mget(x: is_arithmetic, y: is_arithmetic): uint16
    local x, y = (@integer)(x), (@integer)(y)
    if unlikely(x < 0 or y < 0 or x >= neco.mapwidth or y >= neco.mapheight) then return 0 end
    return neco.map[y][x]
  end

  global function mset(x: is_arithmetic, y: is_arithmetic, v: uint16)
    local x, y = (@integer)(x), (@integer)(y)
    if unlikely(x < 0 or y < 0 or x >= neco.mapwidth or y >= neco.mapheight) then return end
    neco.map[y][x] = v
  end

  global function btn(key: integer): boolean
    local pressed_keys: *[0]uint8 = SDL_GetKeyboardState(nilptr)
    local mouse_buttons: uint32 = SDL_GetMouseState(nilptr, nilptr)
    switch key do
    case 0 then
      return pressed_keys[SDL_SCANCODE_LEFT] == 1
    case 1 then
      return pressed_keys[SDL_SCANCODE_RIGHT] == 1
    case 2 then
      return pressed_keys[SDL_SCANCODE_UP] == 1
    case 3 then
      return pressed_keys[SDL_SCANCODE_DOWN] == 1
    case 4 then
      return pressed_keys[SDL_SCANCODE_Z] == 1 or pressed_keys[SDL_SCANCODE_C] == 1
    case 5 then
      return pressed_keys[SDL_SCANCODE_X] == 1
    case 6 then
      return mouse_buttons & SDL_BUTTON_LMASK ~= 0
    case 7 then
      return mouse_buttons & SDL_BUTTON_RMASK ~= 0
    case 8 then
      return mouse_buttons & SDL_BUTTON_MMASK ~= 0
    end
    return false
  end

  global function btnp(key: integer): boolean
    switch key do
    case 0 then
      return neco.keydowns[SDL_SCANCODE_LEFT]
    case 1 then
      return neco.keydowns[SDL_SCANCODE_RIGHT]
    case 2 then
      return neco.keydowns[SDL_SCANCODE_UP]
    case 3 then
      return neco.keydowns[SDL_SCANCODE_DOWN]
    case 4 then
      local z: boolean = neco.keydowns[SDL_SCANCODE_Z]
      local c: boolean = neco.keydowns[SDL_SCANCODE_C]
      return z or c
    case 5 then
      return neco.keydowns[SDL_SCANCODE_X]
    case 6 then
      return neco.mousedowns & SDL_BUTTON_LMASK ~= 0
    case 7 then
      return neco.mousedowns & SDL_BUTTON_RMASK ~= 0
    case 8 then
      return neco.mousedowns & SDL_BUTTON_MMASK ~= 0
    end
    return false
  end

  --------------------------------------------------------------------------------
  -- Audio

  -- TODO: Use SDL2 audio?
  require 'miniaudio'
  local vector = require 'vector'
  local math = require 'math'
  require 'allocators.default'

  -- Macro for quick error handling miniaudio errors.
  ## local function ma_assert(expr)
    local result: ma_result = #[expr]#
    if result ~= MA_SUCCESS then
      panic(ma_result_description(result))
    end
  ## end

  local audio = @record{}

  local WaveFormCallback: type = @function(uniforms: pointer, time: float32): float32
  local WaveForm: type = @record{
    ds: ma_data_source_base,
    callback: WaveFormCallback,
    frame: uint64,
    length: uint64,
    uniforms: [12]float32
  }

  local WaveSound: type = @record{
    wave: *WaveForm,
    sound: *ma_sound,
  }

  function WaveSound:destroy()
    ma_sound_uninit(self.sound)
    default_allocator:delete(self.wave)
    general_allocator:delete(self.sound)
    $self = {}
  end

  local engine: ma_engine <nogcscan>
  local device: *ma_device <nogcscan>
  local waves: vector(WaveSound)
  local bpm_frame: int32 = 0
  local bpm: int32 = 128

  function audio.setup()
    local config: ma_engine_config = ma_engine_config_init()
    config.periodSizeInMilliseconds = 30
    ma_assert!(ma_engine_init(&config, &engine))
    device = ma_engine_get_device(&engine)
    ma_engine_set_volume(&engine, 0.5)
  end

  function audio.shutdown()
    for i,wave in mipairs(waves) do
      wave:destroy()
    end
    waves:destroy()
    ma_engine_uninit(&engine)
  end

  function audio.poll()
    for i,wave in mipairs(waves) do
      if ma_sound_at_end(wave.sound) == MA_TRUE then
        wave:destroy()
      end
    end
    waves:removeif(function(wave: WaveSound)
      return wave.sound == nilptr
    end)
  end

  function WaveForm:_on_read(frames_out: *[0]float32, frame_count: uint64, frames_read: *uint64): ma_result
    if self == nilptr or frame_count == 0 then
      return MA_INVALID_ARGS
    end
    if self.frame > self.length then
      memory.zero(frames_out, frame_count*#@float32)
      $frames_read = 0
      return MA_AT_END
    end
    if frames_read ~= nilptr then
      local sample_rate_inverse: float32 = 1 / ma_engine_get_sample_rate(&engine)
      local frame: uint64 = self.frame
      for i: uint64=0,<frame_count do
        local time: float32 = (frame + i) * sample_rate_inverse
        -- TODO: inline this
        frames_out[i] = self.callback(&self.uniforms, time)
      end
      $frames_read = frame_count
      self.frame = self.frame + frame_count
    end
    return MA_SUCCESS
  end

  function WaveForm:_get_data_format(format: *ma_format, channels: *uint32, sample_rate: *uint32, channel_map: *ma_channel, channel_map_cap: csize): ma_result
    $format = ma_format_f32
    $channels = 1
    $sample_rate = ma_engine_get_sample_rate(&engine)
    ma_channel_map_init_standard(ma_standard_channel_map_default, channel_map, channel_map_cap, 1)
    return MA_SUCCESS
  end

  function WaveForm:_get_length_in_pcm_frames(length: *uint64): ma_result
    $length = self.length
    return MA_SUCCESS
  end

  local monowave_data_source_vtable: ma_data_source_vtable = {
    onRead = (@decltype(ma_data_source_read_pcm_frames))(WaveForm._on_read),
    onSeek = nilptr,
    onGetDataFormat = (@decltype(ma_data_source_get_data_format))(WaveForm._get_data_format),
    onGetCursor = nilptr,
    onGetLength = nilptr,
    onSetLooping = nilptr,
    flags = 0
  }

  function WaveForm:init(): ma_result
    local data_source_config: ma_data_source_config = ma_data_source_config_init()
    data_source_config.vtable = &monowave_data_source_vtable
    ma_assert!(ma_data_source_init(&data_source_config, &self.ds))
    return MA_SUCCESS
  end

  function WaveForm:uninit(): void
    ma_data_source_uninit(&self.ds)
  end

  function audio.wave(desc: auto): void
    ## static_assert(desc.type.size <= 8*32)
    local T: type = @decltype(desc)
    local wave: *WaveForm = default_allocator:new(@WaveForm)
    wave.callback = (@WaveFormCallback)(T.waveform)
    wave.length = math.iceil(desc:total_duration() * ma_engine_get_sample_rate(&engine))
    $(@*T)(&wave.uniforms) = desc
    ma_assert!(wave:init())
    local flags: uint32 = MA_SOUND_FLAG_NO_SPATIALIZATION | MA_SOUND_FLAG_NO_PITCH
    local sound: *ma_sound = general_allocator:new(@ma_sound)
    ma_assert!(ma_sound_init_from_data_source(engine, wave, flags, nilptr, sound))
    ma_assert!(ma_sound_start(sound))
    waves:push{wave,sound}
  end

  global WaveType = @enum(byte){
    SQUARE=0,
    SAW,
    TRIANGLE,
    NOISE,
    WHITE_NOISE,
    SINE,
  }

  local CheapTone = @record{
    start_frequency: float32,
    end_frequency: float32,
    amplitude: float32,
    attack_duration: float32,
    decay_duration: float32,
    sustain_duration: float32,
    release_duration: float32,
    sustain_level: float32,
    duty_cycle: float32,
    wave_type: WaveType,
  }

  local mathx = @record{}
  local mathx.TAU: float32 <comptime> = 6.28318530717958647693

  function mathx.linearstep(a: auto, b: auto, x: auto) <inline,nosideeffect>
    return math.clamp((x-a)/(b-a), 0, 1)
  end

  function mathx.smoothstep(edge0: auto, edge1: auto, x: auto) <inline,nosideeffect>
    local t = math.clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0)
    return t * t * (3.0 - 2.0 * t)
  end

  function mathx.mix(a: auto, b: auto, t: auto) <inline,nosideeffect>
    return a + (b-a) * t
  end

  function mathx.hash1(x: float32): float32 <inline,nosideeffect>
    local v: uint32 = ((@union{f: float32, i: uint32}){f = x}).i
    v = 1103515245_u32 * (v ~ (v>>1_u))
    local h: uint32 = 1103515245_u32 * (v ~ (v>>3_u32))
    h = h ~ (h>>16_u32)
    return (h & 0x7fffffff_u32)*(@float32)(#[1.0/0x7fffffff]#)
  end

  function mathx.valuenoise(x: float32)
    local i, f = math.floor(x), math.fract(x)
    local I = math.floor(i + 1.0)
    local a: float32 = mathx.hash1(i)
    local b: float32 = mathx.hash1(I)
    local u: float32 = f*f*(3.0-2.0*f) -- cubic interpolation
    return mathx.mix(a, b, u)
  end

  function CheapTone:total_duration()
    return self.attack_duration + self.decay_duration + self.sustain_duration + self.release_duration
  end

  function CheapTone:waveform(time: float32): float32 <inline>
    local play_duration = self.attack_duration + self.decay_duration + self.sustain_duration
    local total_duration = play_duration + self.release_duration
    local attack = mathx.linearstep(0.0_f32, self.attack_duration, time)
    local release = mathx.linearstep(total_duration, play_duration, time)
    local decay = mathx.linearstep(self.attack_duration, self.attack_duration + self.decay_duration, time)
    local decay_level = mathx.mix(1.0, self.sustain_level, mathx.linearstep(self.attack_duration, self.attack_duration + self.decay_duration, time))
    local x = time * mathx.mix(self.start_frequency, self.end_frequency, time / play_duration)
    local wave: float32
    switch self.wave_type do
    case WaveType.SINE then
      wave = math.sin(x * mathx.TAU) -- sine
    case WaveType.SAW then
      wave = 0.5*(2*math.fract(x) - 1) -- saw
    case WaveType.SQUARE then
      wave = 0.5*2*(math.fract(x+self.duty_cycle)-math.fract(x)) -- square
    case WaveType.TRIANGLE then
      wave = (math.abs(4*math.fract(x)-2)-1) -- triangle
    case WaveType.WHITE_NOISE then
      wave = mathx.hash1(x) -- noise 1
    case WaveType.NOISE then
      wave = mathx.valuenoise(x*16) -- noise 2
    end
    local level = attack * decay_level * release
    return math.clamp(wave * (level * level * self.amplitude), -1.0, 1.0)
  end

  global ToneDesc = @record{
    start_frequency: float32,
    end_frequency: float32,
    duty_cycle: float32,
    attack: uint32,
    decay: uint32,
    sustain: uint32,
    release: uint32,
    volume: float32,
    wave_type: WaveType,
  }

  global function tonex(desc: ToneDesc)
    desc.attack = math.max(desc.attack, 1)
    desc.release = math.max(desc.release, 1)
    audio.wave(CheapTone{
      start_frequency = desc.start_frequency,
      end_frequency = desc.end_frequency == 0 and desc.start_frequency or desc.end_frequency,
      amplitude =  desc.volume,
      attack_duration = desc.attack / 60,
      decay_duration = desc.decay / 60,
      sustain_duration = desc.sustain / 60,
      release_duration = desc.release / 60,
      duty_cycle = desc.duty_cycle ~= 0 and desc.duty_cycle or 0.5,
      sustain_level = 1.0,
      wave_type = desc.wave_type,
    })
  end

## end

--------------------------------------------------------------------------------
-- Neco run

## function neco_run()
  -- setup window

  if SDL_Init(SDL_INIT_VIDEO) ~= 0 then
    error 'Could not initialize SDL'
  end
  local window: *SDL_Window = SDL_CreateWindow(neco.title,
    SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,
    neco.width*neco.scale, neco.height*neco.scale,
    0)
  if not window then
    error 'Could not create SDL Window'
  end

  local renderer: *SDL_Renderer = SDL_CreateRenderer(window, -1, 0)
  if not renderer then
    error 'Could not create SDL Renderer'
  end

  local texture: *SDL_Texture = SDL_CreateTexture(renderer, SDL_PIXELFORMAT_XBGR8888, SDL_TEXTUREACCESS_STREAMING, neco.width, neco.height)
  if not texture then
    error 'Could not create SDL Texture'
  end

  audio.setup()

  -- init game
  ## if symbols._init then
    _init()
  ## end

  local first_counter: uint64 = SDL_GetPerformanceCounter()
  global function clock(): number
    return (SDL_GetPerformanceCounter() - first_counter + 3600*10) / SDL_GetPerformanceFrequency()
  end

  local next_flip: number = 0.0
  global function flip()
    for y=0,<neco.height do
      for x=0,<neco.width do
        neco.renderpixels[y][x] = neco.palette[neco.scnpalette[neco.pixels[y][x]]]
      end
    end
    SDL_UpdateTexture(texture, nilptr, &neco.renderpixels, 4*neco.width)
    SDL_RenderCopy(renderer, texture, nilptr, nilptr)

    ## if not ccinfo.is_emscripten then
    local now: number = clock()
    if next_flip > now then
      local ms = math.ifloor((next_flip - now) * 1000 + 0.5)
      SDL_Delay(ms)
      next_flip = next_flip + (1.0/neco.fps)
    else
      next_flip = now + (1.0/neco.fps)
    end
    ## end
    SDL_RenderPresent(renderer)
  end

  local quit: boolean = false
  local function poll()
    neco.keydowns = {}
    neco.mousedowns = 0
    local event: SDL_Event
    while SDL_PollEvent(&event) == 1 do
      switch event.type do
      case SDL_KEYDOWN then
        neco.keydowns[event.key.keysym.scancode] = true
      case SDL_MOUSEBUTTONDOWN then
        switch event.button.button do
        case SDL_BUTTON_LEFT then neco.mousedowns = neco.mousedowns | SDL_BUTTON_LMASK
        case SDL_BUTTON_MIDDLE then neco.mousedowns = neco.mousedowns | SDL_BUTTON_MMASK
        case SDL_BUTTON_RIGHT then neco.mousedowns = neco.mousedowns | SDL_BUTTON_RMASK
        end
      case SDL_QUIT then
        quit = true
      end
    end
  end

  local fps: number = 0.0
  local last_fps: number = 0.0
  local function frame()
    poll()
    audio.poll()
    ## if symbols._update then
      _update()
    ## end
    _draw()
    flip()
    neco.frametime = neco.frametime + (1/neco.fps)

    ## if ccinfo.is_wasm and not pragmas.nogc then
      gc:step() -- safe to collect garbage here
    ## end

    fps = fps + 1
    -- FIXME: with time this may lose precision
    local now: number = clock()
    if now >= last_fps + 1.0 then
      fps = math.floor(((fps * 100.0) / (now - last_fps)) + 0.5) / 100.0
      trace("FPS", fps)
      fps = 0
      last_fps = now
    end
  end

  ## if ccinfo.is_emscripten then
    local function emscripten_set_main_loop(func: function(), fps: cint, infloop: cint) <cimport,cinclude'<emscripten.h>',nodecl> end
    emscripten_set_main_loop(frame, neco.fps, 1)
  ## else
    repeat
      frame()
    until quit
  ## end

  -- cleanup
  ## if symbols._terminate then
    _terminate()
  ## end
  SDL_DestroyTexture(texture)
  SDL_DestroyRenderer(renderer)
  SDL_DestroyWindow(window)
  SDL_Quit()
  audio.shutdown()
## end
